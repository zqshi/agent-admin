# CogVision 部署运维指南

## 目录
1. [环境准备](#1-环境准备)
2. [前端部署](#2-前端部署)
3. [后端部署](#3-后端部署)
4. [数据库配置](#4-数据库配置)
5. [容器化部署](#5-容器化部署)
6. [Kubernetes部署](#6-kubernetes部署)
7. [CI/CD流水线](#7-cicd流水线)
8. [监控告警](#8-监控告警)
9. [日常运维](#9-日常运维)
10. [故障排查](#10-故障排查)

---

## 1. 环境准备

### 1.1 系统要求

**前端环境:**
- Node.js 18.x+ 
- npm 8.x+ 或 yarn 1.22+
- 内存: 最少2GB，推荐4GB+
- 磁盘: 最少10GB可用空间

**后端环境:**
- CPU: 最少2核，推荐4核+
- 内存: 最少4GB，推荐8GB+
- 磁盘: 最少50GB SSD
- 网络: 1Gbps带宽

**数据库环境:**
- PostgreSQL 14+
- InfluxDB 2.x
- Redis 6.x+

### 1.2 网络配置

**端口配置:**
```bash
# 前端应用
3000/tcp    # 开发服务器
80/tcp      # HTTP (生产环境)
443/tcp     # HTTPS (生产环境)

# 后端服务
8080/tcp    # API服务
8081/tcp    # 管理接口

# 数据库
5432/tcp    # PostgreSQL
8086/tcp    # InfluxDB
6379/tcp    # Redis
```

**防火墙配置:**
```bash
# CentOS/RHEL
firewall-cmd --permanent --add-port=80/tcp
firewall-cmd --permanent --add-port=443/tcp
firewall-cmd --reload

# Ubuntu/Debian
ufw allow 80/tcp
ufw allow 443/tcp
ufw enable
```

### 1.3 依赖安装

**安装Node.js:**
```bash
# 使用NVM安装Node.js
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
source ~/.bashrc
nvm install 18
nvm use 18
nvm alias default 18

# 验证安装
node --version
npm --version
```

**安装Docker (可选):**
```bash
# Ubuntu/Debian
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER

# CentOS/RHEL
sudo yum install -y yum-utils
sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
sudo yum install -y docker-ce docker-ce-cli containerd.io
sudo systemctl enable docker
sudo systemctl start docker
```

---

## 2. 前端部署

### 2.1 生产构建

**克隆代码:**
```bash
git clone https://github.com/your-org/cogvision-admin.git
cd cogvision-admin
```

**安装依赖并构建:**
```bash
# 安装依赖
npm ci --only=production

# 构建生产版本
npm run build

# 验证构建产物
ls -la dist/
```

### 2.2 Nginx配置

**安装Nginx:**
```bash
# Ubuntu/Debian
sudo apt update && sudo apt install -y nginx

# CentOS/RHEL
sudo yum install -y nginx
```

**配置文件 (`/etc/nginx/sites-available/cogvision`):**
```nginx
server {
    listen 80;
    server_name cogvision.yourdomain.com;
    root /var/www/cogvision/dist;
    index index.html;

    # 处理React Router
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API代理
    location /api/ {
        proxy_pass http://localhost:8080/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, no-transform";
    }

    # 压缩配置
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;
}
```

**启用配置:**
```bash
# 创建符号链接
sudo ln -s /etc/nginx/sites-available/cogvision /etc/nginx/sites-enabled/

# 测试配置
sudo nginx -t

# 重启Nginx
sudo systemctl restart nginx
sudo systemctl enable nginx
```

### 2.3 HTTPS配置 (使用Let's Encrypt)

**安装Certbot:**
```bash
# Ubuntu/Debian
sudo apt install -y certbot python3-certbot-nginx

# CentOS/RHEL
sudo yum install -y certbot python3-certbot-nginx
```

**获取SSL证书:**
```bash
sudo certbot --nginx -d cogvision.yourdomain.com
```

**自动续期:**
```bash
# 添加cron任务
echo "0 12 * * * /usr/bin/certbot renew --quiet" | sudo crontab -
```

### 2.4 部署脚本

**创建部署脚本 (`deploy.sh`):**
```bash
#!/bin/bash
set -e

PROJECT_DIR="/var/www/cogvision"
BACKUP_DIR="/var/backups/cogvision"
NGINX_CONFIG="/etc/nginx/sites-available/cogvision"

echo "🚀 开始部署 CogVision 前端..."

# 创建备份
echo "📦 创建备份..."
sudo mkdir -p $BACKUP_DIR
sudo tar -czf $BACKUP_DIR/cogvision-$(date +%Y%m%d-%H%M%S).tar.gz -C $PROJECT_DIR .

# 拉取最新代码
echo "📥 拉取最新代码..."
cd $PROJECT_DIR
git pull origin main

# 安装依赖
echo "📦 安装依赖..."
npm ci --only=production

# 构建应用
echo "🔧 构建应用..."
npm run build

# 重启Nginx
echo "🔄 重启Nginx..."
sudo nginx -t && sudo systemctl reload nginx

echo "✅ 部署完成!"
echo "🌐 访问地址: https://cogvision.yourdomain.com"
```

---

## 3. 后端部署

### 3.1 Python后端 (示例)

**依赖安装:**
```bash
# 创建虚拟环境
python3 -m venv venv
source venv/bin/activate

# 安装依赖
pip install -r requirements.txt
```

**配置文件 (`config/production.py`):**
```python
import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY')
    
    # 数据库配置
    POSTGRES_URL = os.environ.get('POSTGRES_URL')
    INFLUXDB_URL = os.environ.get('INFLUXDB_URL')
    REDIS_URL = os.environ.get('REDIS_URL')
    
    # JWT配置
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY')
    JWT_EXPIRATION_HOURS = 24
    
    # API配置
    API_RATE_LIMIT = "1000 per hour"
    CORS_ORIGINS = ["https://cogvision.yourdomain.com"]
    
    # 监控配置
    PROMETHEUS_ENABLED = True
    HEALTH_CHECK_ENABLED = True
```

**Systemd服务配置 (`/etc/systemd/system/cogvision-api.service`):**
```ini
[Unit]
Description=CogVision API Server
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/opt/cogvision-api
Environment=PATH=/opt/cogvision-api/venv/bin
ExecStart=/opt/cogvision-api/venv/bin/python app.py
Restart=always
RestartSec=10

# 环境变量
Environment=FLASK_ENV=production
Environment=SECRET_KEY=your-secret-key
Environment=POSTGRES_URL=postgresql://user:pass@localhost:5432/cogvision
Environment=REDIS_URL=redis://localhost:6379/0

[Install]
WantedBy=multi-user.target
```

**启动服务:**
```bash
sudo systemctl daemon-reload
sudo systemctl enable cogvision-api
sudo systemctl start cogvision-api
sudo systemctl status cogvision-api
```

### 3.2 Node.js后端 (示例)

**安装依赖:**
```bash
cd cogvision-api
npm ci --only=production
```

**配置文件 (`config/production.json`):**
```json
{
  "server": {
    "port": 8080,
    "host": "0.0.0.0"
  },
  "database": {
    "postgres": {
      "host": "localhost",
      "port": 5432,
      "database": "cogvision",
      "username": "cogvision_user",
      "password": "${POSTGRES_PASSWORD}"
    },
    "influxdb": {
      "url": "http://localhost:8086",
      "token": "${INFLUXDB_TOKEN}",
      "org": "cogvision",
      "bucket": "metrics"
    },
    "redis": {
      "host": "localhost",
      "port": 6379,
      "password": "${REDIS_PASSWORD}"
    }
  },
  "auth": {
    "jwtSecret": "${JWT_SECRET}",
    "tokenExpiration": "24h"
  },
  "logging": {
    "level": "info",
    "format": "json"
  }
}
```

**PM2配置 (`ecosystem.config.js`):**
```javascript
module.exports = {
  apps: [{
    name: 'cogvision-api',
    script: 'dist/server.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 8080
    },
    env_production: {
      NODE_ENV: 'production',
      PORT: 8080,
      POSTGRES_PASSWORD: process.env.POSTGRES_PASSWORD,
      JWT_SECRET: process.env.JWT_SECRET
    },
    log_file: './logs/combined.log',
    out_file: './logs/out.log',
    error_file: './logs/error.log',
    log_date_format: 'YYYY-MM-DD HH:mm Z',
    max_memory_restart: '2G'
  }]
}
```

---

## 4. 数据库配置

### 4.1 PostgreSQL配置

**安装PostgreSQL:**
```bash
# Ubuntu/Debian
sudo apt install -y postgresql postgresql-contrib

# CentOS/RHEL
sudo yum install -y postgresql-server postgresql-contrib
sudo postgresql-setup initdb
```

**创建数据库和用户:**
```sql
-- 连接到PostgreSQL
sudo -u postgres psql

-- 创建数据库和用户
CREATE DATABASE cogvision;
CREATE USER cogvision_user WITH PASSWORD 'your-secure-password';
GRANT ALL PRIVILEGES ON DATABASE cogvision TO cogvision_user;

-- 退出
\q
```

**配置文件优化 (`/etc/postgresql/14/main/postgresql.conf`):**
```conf
# 内存配置
shared_buffers = 256MB
effective_cache_size = 1GB
work_mem = 4MB
maintenance_work_mem = 64MB

# 连接配置
max_connections = 200
listen_addresses = '*'

# 日志配置
log_destination = 'csvlog'
logging_collector = on
log_directory = 'pg_log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_min_duration_statement = 1000

# 性能配置
checkpoint_completion_target = 0.7
wal_buffers = 16MB
default_statistics_target = 100
```

### 4.2 InfluxDB配置

**安装InfluxDB:**
```bash
# 下载和安装
wget -qO- https://repos.influxdata.com/influxdb.key | sudo apt-key add -
echo "deb https://repos.influxdata.com/ubuntu focal stable" | sudo tee /etc/apt/sources.list.d/influxdb.list
sudo apt update && sudo apt install -y influxdb2
```

**初始化配置:**
```bash
# 启动服务
sudo systemctl enable influxdb
sudo systemctl start influxdb

# 初始化设置
influx setup \
  --username admin \
  --password your-secure-password \
  --org cogvision \
  --bucket metrics \
  --force
```

**配置文件 (`/etc/influxdb/config.toml`):**
```toml
[meta]
  dir = "/var/lib/influxdb/meta"

[data]
  dir = "/var/lib/influxdb/data"
  wal-dir = "/var/lib/influxdb/wal"

[http]
  enabled = true
  bind-address = ":8086"
  auth-enabled = true
  log-enabled = true
  write-tracing = false
  pprof-enabled = false

[logging]
  format = "auto"
  level = "info"
  suppress-logo = false
```

### 4.3 Redis配置

**安装Redis:**
```bash
# Ubuntu/Debian
sudo apt install -y redis-server

# CentOS/RHEL
sudo yum install -y redis
```

**配置文件 (`/etc/redis/redis.conf`):**
```conf
# 网络配置
bind 127.0.0.1
port 6379
protected-mode yes

# 认证
requirepass your-redis-password

# 内存配置
maxmemory 1gb
maxmemory-policy allkeys-lru

# 持久化
save 900 1
save 300 10
save 60 10000

# 日志
loglevel notice
logfile /var/log/redis/redis-server.log

# 安全
rename-command FLUSHDB ""
rename-command FLUSHALL ""
rename-command DEBUG ""
```

---

## 5. 容器化部署

### 5.1 前端Dockerfile

**创建 `Dockerfile.frontend`:**
```dockerfile
# 构建阶段
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

COPY . .
RUN npm run build

# 生产阶段
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制Nginx配置
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost/ || exit 1

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**Nginx配置 (`nginx.conf`):**
```nginx
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api/ {
        proxy_pass http://cogvision-api:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, no-transform";
    }

    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
}
```

### 5.2 后端Dockerfile

**创建 `Dockerfile.backend`:**
```dockerfile
FROM node:18-alpine

# 安装必要的系统依赖
RUN apk add --no-cache \
    python3 \
    make \
    g++ \
    curl

WORKDIR /app

# 复制依赖文件
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# 切换到非root用户
USER nodejs

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

EXPOSE 8080
CMD ["node", "dist/server.js"]
```

### 5.3 Docker Compose配置

**创建 `docker-compose.yml`:**
```yaml
version: '3.8'

services:
  # 前端服务
  frontend:
    build:
      context: .
      dockerfile: Dockerfile.frontend
    container_name: cogvision-frontend
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./ssl:/etc/ssl/certs:ro
    depends_on:
      - backend
    restart: unless-stopped
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.frontend.rule=Host(`cogvision.yourdomain.com`)"

  # 后端服务
  backend:
    build:
      context: ./api
      dockerfile: Dockerfile.backend
    container_name: cogvision-backend
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=production
      - POSTGRES_URL=postgresql://cogvision_user:${POSTGRES_PASSWORD}@postgres:5432/cogvision
      - REDIS_URL=redis://redis:6379
      - INFLUXDB_URL=http://influxdb:8086
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - postgres
      - redis
      - influxdb
    restart: unless-stopped
    volumes:
      - ./logs:/app/logs

  # PostgreSQL数据库
  postgres:
    image: postgres:14-alpine
    container_name: cogvision-postgres
    environment:
      - POSTGRES_DB=cogvision
      - POSTGRES_USER=cogvision_user
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/init.sql:ro
    ports:
      - "5432:5432"
    restart: unless-stopped

  # InfluxDB时序数据库
  influxdb:
    image: influxdb:2.3-alpine
    container_name: cogvision-influxdb
    environment:
      - DOCKER_INFLUXDB_INIT_MODE=setup
      - DOCKER_INFLUXDB_INIT_USERNAME=admin
      - DOCKER_INFLUXDB_INIT_PASSWORD=${INFLUXDB_PASSWORD}
      - DOCKER_INFLUXDB_INIT_ORG=cogvision
      - DOCKER_INFLUXDB_INIT_BUCKET=metrics
    volumes:
      - influxdb_data:/var/lib/influxdb2
    ports:
      - "8086:8086"
    restart: unless-stopped

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: cogvision-redis
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    restart: unless-stopped

volumes:
  postgres_data:
  influxdb_data:
  redis_data:

networks:
  default:
    name: cogvision-network
```

**环境变量文件 (`.env`):**
```bash
# 数据库密码
POSTGRES_PASSWORD=your-secure-postgres-password
REDIS_PASSWORD=your-secure-redis-password
INFLUXDB_PASSWORD=your-secure-influxdb-password

# JWT密钥
JWT_SECRET=your-jwt-secret-key

# 域名配置
DOMAIN=cogvision.yourdomain.com

# 监控配置
ENABLE_MONITORING=true
```

**启动服务:**
```bash
# 启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f backend
```

---

## 6. Kubernetes部署

### 6.1 命名空间配置

**创建 `k8s/namespace.yaml`:**
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: cogvision
  labels:
    name: cogvision
```

### 6.2 ConfigMap配置

**创建 `k8s/configmap.yaml`:**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cogvision-config
  namespace: cogvision
data:
  postgres_host: "cogvision-postgres"
  postgres_port: "5432"
  postgres_database: "cogvision"
  redis_host: "cogvision-redis"
  redis_port: "6379"
  influxdb_url: "http://cogvision-influxdb:8086"
  jwt_expiration: "24h"
  log_level: "info"
```

### 6.3 Secret配置

**创建 `k8s/secret.yaml`:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: cogvision-secrets
  namespace: cogvision
type: Opaque
data:
  postgres_password: <base64-encoded-password>
  redis_password: <base64-encoded-password>
  jwt_secret: <base64-encoded-secret>
  influxdb_token: <base64-encoded-token>
```

### 6.4 前端部署

**创建 `k8s/frontend-deployment.yaml`:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cogvision-frontend
  namespace: cogvision
spec:
  replicas: 3
  selector:
    matchLabels:
      app: cogvision-frontend
  template:
    metadata:
      labels:
        app: cogvision-frontend
    spec:
      containers:
      - name: frontend
        image: cogvision/frontend:latest
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: cogvision-frontend
  namespace: cogvision
spec:
  selector:
    app: cogvision-frontend
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

### 6.5 后端部署

**创建 `k8s/backend-deployment.yaml`:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cogvision-backend
  namespace: cogvision
spec:
  replicas: 2
  selector:
    matchLabels:
      app: cogvision-backend
  template:
    metadata:
      labels:
        app: cogvision-backend
    spec:
      containers:
      - name: backend
        image: cogvision/backend:latest
        ports:
        - containerPort: 8080
        env:
        - name: NODE_ENV
          value: "production"
        - name: POSTGRES_HOST
          valueFrom:
            configMapKeyRef:
              name: cogvision-config
              key: postgres_host
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: cogvision-secrets
              key: postgres_password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: cogvision-secrets
              key: jwt_secret
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: cogvision-backend
  namespace: cogvision
spec:
  selector:
    app: cogvision-backend
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP
```

### 6.6 数据库部署

**PostgreSQL StatefulSet (`k8s/postgres.yaml`):**
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: cogvision-postgres
  namespace: cogvision
spec:
  serviceName: cogvision-postgres
  replicas: 1
  selector:
    matchLabels:
      app: cogvision-postgres
  template:
    metadata:
      labels:
        app: cogvision-postgres
    spec:
      containers:
      - name: postgres
        image: postgres:14-alpine
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_DB
          value: cogvision
        - name: POSTGRES_USER
          value: cogvision_user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: cogvision-secrets
              key: postgres_password
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 20Gi

---
apiVersion: v1
kind: Service
metadata:
  name: cogvision-postgres
  namespace: cogvision
spec:
  selector:
    app: cogvision-postgres
  ports:
  - port: 5432
    targetPort: 5432
  type: ClusterIP
```

### 6.7 Ingress配置

**创建 `k8s/ingress.yaml`:**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: cogvision-ingress
  namespace: cogvision
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  tls:
  - hosts:
    - cogvision.yourdomain.com
    secretName: cogvision-tls
  rules:
  - host: cogvision.yourdomain.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: cogvision-backend
            port:
              number: 8080
      - path: /
        pathType: Prefix
        backend:
          service:
            name: cogvision-frontend
            port:
              number: 80
```

**部署到Kubernetes:**
```bash
# 应用所有配置
kubectl apply -f k8s/

# 查看部署状态
kubectl get pods -n cogvision
kubectl get services -n cogvision
kubectl get ingress -n cogvision

# 查看日志
kubectl logs -f deployment/cogvision-backend -n cogvision
```

---

## 7. CI/CD流水线

### 7.1 GitHub Actions配置

**创建 `.github/workflows/ci-cd.yml`:**
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linter
      run: npm run lint
    
    - name: Run tests
      run: npm run test:coverage
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        file: Dockerfile.frontend
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.24.0'
    
    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
    
    - name: Deploy to Kubernetes
      run: |
        kubectl set image deployment/cogvision-frontend \
          frontend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main-${{ github.sha }} \
          -n cogvision
        kubectl rollout status deployment/cogvision-frontend -n cogvision
        
    - name: Notify deployment
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      if: always()
```

### 7.2 GitLab CI配置

**创建 `.gitlab-ci.yml`:**
```yaml
stages:
  - test
  - build
  - deploy

variables:
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_DRIVER: overlay2

test:
  stage: test
  image: node:18-alpine
  cache:
    paths:
      - node_modules/
  script:
    - npm ci
    - npm run lint
    - npm run test:coverage
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

build:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -f Dockerfile.frontend -t $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/frontend:latest
    - docker push $CI_REGISTRY_IMAGE/frontend:latest
  only:
    - main

deploy:
  stage: deploy
  image: alpine/helm:3.9.0
  before_script:
    - apk add --no-cache curl
    - curl -LO "https://dl.k8s.io/release/v1.24.0/bin/linux/amd64/kubectl"
    - install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
  script:
    - echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
    - kubectl set image deployment/cogvision-frontend frontend=$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA -n cogvision
    - kubectl rollout status deployment/cogvision-frontend -n cogvision
  environment:
    name: production
    url: https://cogvision.yourdomain.com
  only:
    - main
```

---

## 8. 监控告警

### 8.1 Prometheus配置

**创建 `prometheus/prometheus.yml`:**
```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "cogvision_rules.yml"

scrape_configs:
  - job_name: 'cogvision-frontend'
    static_configs:
      - targets: ['localhost:3000']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'cogvision-backend'
    static_configs:
      - targets: ['localhost:8080']
    metrics_path: '/metrics'
    scrape_interval: 15s

  - job_name: 'postgres'
    static_configs:
      - targets: ['localhost:9187']

  - job_name: 'redis'
    static_configs:
      - targets: ['localhost:9121']

  - job_name: 'nginx'
    static_configs:
      - targets: ['localhost:9113']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - localhost:9093
```

**告警规则 (`prometheus/cogvision_rules.yml`):**
```yaml
groups:
  - name: cogvision.rules
    rules:
      # 应用健康检查
      - alert: ApplicationDown
        expr: up{job=~"cogvision-.*"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "CogVision应用 {{ $labels.instance }} 宕机"
          description: "应用 {{ $labels.job }} 在 {{ $labels.instance }} 上已经宕机超过1分钟"

      # 高错误率告警
      - alert: HighErrorRate
        expr: |
          (
            rate(http_requests_total{job="cogvision-backend",code=~"5.."}[5m]) /
            rate(http_requests_total{job="cogvision-backend"}[5m])
          ) * 100 > 5
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "CogVision后端错误率过高"
          description: "错误率已达到 {{ $value }}%，超过5%阈值"

      # 响应时间告警
      - alert: HighResponseTime
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{job="cogvision-backend"}[5m])) > 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "CogVision后端响应时间过长"
          description: "95%分位响应时间为 {{ $value }}秒，超过2秒阈值"

      # 内存使用告警
      - alert: HighMemoryUsage
        expr: |
          (
            process_resident_memory_bytes{job=~"cogvision-.*"} /
            (1024*1024*1024)
          ) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "CogVision应用内存使用过高"
          description: "{{ $labels.job }} 内存使用已达到 {{ $value }}GB"

      # 数据库连接告警
      - alert: DatabaseConnectionHigh
        expr: pg_stat_activity_count{job="postgres"} > 150
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "数据库连接数过高"
          description: "PostgreSQL连接数为 {{ $value }}，接近限制"
```

### 8.2 Grafana仪表盘

**导入仪表盘配置 (`grafana/cogvision-dashboard.json`):**
```json
{
  "dashboard": {
    "id": null,
    "title": "CogVision 监控仪表盘",
    "tags": ["cogvision", "monitoring"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "应用状态",
        "type": "stat",
        "targets": [
          {
            "expr": "up{job=~\"cogvision-.*\"}",
            "legendFormat": "{{job}}"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "mappings": [
              {
                "options": {
                  "0": {
                    "text": "下线",
                    "color": "red"
                  },
                  "1": {
                    "text": "在线",
                    "color": "green"
                  }
                },
                "type": "value"
              }
            ]
          }
        },
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0}
      },
      {
        "id": 2,
        "title": "请求量 (QPS)",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total{job=\"cogvision-backend\"}[5m])",
            "legendFormat": "{{method}} {{handler}}"
          }
        ],
        "yAxes": [
          {
            "label": "请求/秒",
            "min": 0
          }
        ],
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 0}
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
}
```

### 8.3 告警通知配置

**AlertManager配置 (`alertmanager/alertmanager.yml`):**
```yaml
global:
  smtp_smarthost: 'smtp.company.com:587'
  smtp_from: 'alerts@cogvision.com'

route:
  group_by: ['alertname']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'web.hook'
  routes:
    - match:
        severity: critical
      receiver: 'critical-alerts'
    - match:
        severity: warning
      receiver: 'warning-alerts'

receivers:
  - name: 'web.hook'
    webhook_configs:
      - url: 'http://127.0.0.1:5001/'

  - name: 'critical-alerts'
    email_configs:
      - to: 'ops-team@company.com'
        subject: '🚨 CogVision严重告警: {{ .GroupLabels.alertname }}'
        body: |
          {{ range .Alerts }}
          告警: {{ .Annotations.summary }}
          详情: {{ .Annotations.description }}
          时间: {{ .StartsAt }}
          {{ end }}
    slack_configs:
      - api_url: 'YOUR_SLACK_WEBHOOK_URL'
        channel: '#alerts'
        title: 'CogVision严重告警'
        text: |
          {{ range .Alerts }}
          🚨 {{ .Annotations.summary }}
          {{ .Annotations.description }}
          {{ end }}

  - name: 'warning-alerts'
    email_configs:
      - to: 'dev-team@company.com'
        subject: '⚠️ CogVision告警: {{ .GroupLabels.alertname }}'
        body: |
          {{ range .Alerts }}
          告警: {{ .Annotations.summary }}
          详情: {{ .Annotations.description }}
          时间: {{ .StartsAt }}
          {{ end }}
```

---

## 9. 日常运维

### 9.1 健康检查脚本

**创建健康检查脚本 (`scripts/health-check.sh`):**
```bash
#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 配置
FRONTEND_URL="https://cogvision.yourdomain.com"
BACKEND_URL="https://api.cogvision.com"
DB_HOST="localhost"

echo "🔍 CogVision 系统健康检查"
echo "=========================="

# 检查前端服务
echo -n "检查前端服务... "
if curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL" | grep -q "200"; then
    echo -e "${GREEN}✓ 正常${NC}"
else
    echo -e "${RED}✗ 异常${NC}"
fi

# 检查后端API
echo -n "检查后端API... "
if curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL/health" | grep -q "200"; then
    echo -e "${GREEN}✓ 正常${NC}"
else
    echo -e "${RED}✗ 异常${NC}"
fi

# 检查数据库连接
echo -n "检查PostgreSQL... "
if pg_isready -h $DB_HOST -p 5432 -q; then
    echo -e "${GREEN}✓ 正常${NC}"
else
    echo -e "${RED}✗ 异常${NC}"
fi

# 检查Redis
echo -n "检查Redis... "
if redis-cli -h $DB_HOST ping | grep -q "PONG"; then
    echo -e "${GREEN}✓ 正常${NC}"
else
    echo -e "${RED}✗ 异常${NC}"
fi

# 检查磁盘空间
echo -n "检查磁盘空间... "
DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
if [ $DISK_USAGE -lt 80 ]; then
    echo -e "${GREEN}✓ 正常 (${DISK_USAGE}%)${NC}"
elif [ $DISK_USAGE -lt 90 ]; then
    echo -e "${YELLOW}⚠ 警告 (${DISK_USAGE}%)${NC}"
else
    echo -e "${RED}✗ 危险 (${DISK_USAGE}%)${NC}"
fi

# 检查内存使用
echo -n "检查内存使用... "
MEM_USAGE=$(free | grep Mem | awk '{printf("%.1f", $3/$2 * 100.0)}')
if (( $(echo "$MEM_USAGE < 80" | bc -l) )); then
    echo -e "${GREEN}✓ 正常 (${MEM_USAGE}%)${NC}"
elif (( $(echo "$MEM_USAGE < 90" | bc -l) )); then
    echo -e "${YELLOW}⚠ 警告 (${MEM_USAGE}%)${NC}"
else
    echo -e "${RED}✗ 危险 (${MEM_USAGE}%)${NC}"
fi

echo "=========================="
echo "健康检查完成 $(date)"
```

### 9.2 备份脚本

**创建数据库备份脚本 (`scripts/backup.sh`):**
```bash
#!/bin/bash

# 配置
BACKUP_DIR="/var/backups/cogvision"
DB_NAME="cogvision"
DB_USER="cogvision_user"
RETENTION_DAYS=30

# 创建备份目录
mkdir -p $BACKUP_DIR

# 生成时间戳
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

echo "🗄️ 开始备份 CogVision 数据库..."

# PostgreSQL备份
echo "备份PostgreSQL数据库..."
pg_dump -h localhost -U $DB_USER -d $DB_NAME -f "$BACKUP_DIR/postgres_${TIMESTAMP}.sql"
if [ $? -eq 0 ]; then
    echo "✅ PostgreSQL备份成功"
    gzip "$BACKUP_DIR/postgres_${TIMESTAMP}.sql"
else
    echo "❌ PostgreSQL备份失败"
    exit 1
fi

# InfluxDB备份
echo "备份InfluxDB数据..."
influx backup -t $(cat ~/.influxdb_token) "$BACKUP_DIR/influxdb_${TIMESTAMP}"
if [ $? -eq 0 ]; then
    echo "✅ InfluxDB备份成功"
    tar -czf "$BACKUP_DIR/influxdb_${TIMESTAMP}.tar.gz" -C "$BACKUP_DIR" "influxdb_${TIMESTAMP}"
    rm -rf "$BACKUP_DIR/influxdb_${TIMESTAMP}"
else
    echo "❌ InfluxDB备份失败"
fi

# 清理旧备份
echo "清理超过 ${RETENTION_DAYS} 天的旧备份..."
find $BACKUP_DIR -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete
find $BACKUP_DIR -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete

echo "🎉 备份完成！"
echo "备份文件位置: $BACKUP_DIR"
ls -lh $BACKUP_DIR/*${TIMESTAMP}*
```

### 9.3 日志清理脚本

**创建日志清理脚本 (`scripts/log-cleanup.sh`):**
```bash
#!/bin/bash

# 配置
LOG_DIRS=(
    "/var/log/nginx"
    "/var/log/postgresql"
    "/opt/cogvision/logs"
    "/var/lib/docker/containers"
)
RETENTION_DAYS=30

echo "🧹 开始清理系统日志..."

for LOG_DIR in "${LOG_DIRS[@]}"; do
    if [ -d "$LOG_DIR" ]; then
        echo "清理目录: $LOG_DIR"
        
        # 删除超过保留期的日志文件
        find "$LOG_DIR" -name "*.log" -mtime +$RETENTION_DAYS -delete 2>/dev/null
        find "$LOG_DIR" -name "*.log.*" -mtime +$RETENTION_DAYS -delete 2>/dev/null
        find "$LOG_DIR" -name "*.gz" -mtime +$RETENTION_DAYS -delete 2>/dev/null
        
        echo "✅ $LOG_DIR 清理完成"
    else
        echo "⚠️ 目录不存在: $LOG_DIR"
    fi
done

# 清理系统日志
echo "清理systemd日志..."
journalctl --vacuum-time=${RETENTION_DAYS}d

# 清理Docker日志
echo "清理Docker日志..."
if command -v docker &> /dev/null; then
    docker system prune -f --volumes
fi

echo "🎉 日志清理完成！"

# 显示磁盘使用情况
echo "当前磁盘使用情况:"
df -h
```

### 9.4 性能监控脚本

**创建性能监控脚本 (`scripts/performance-monitor.sh`):**
```bash
#!/bin/bash

# 配置
REPORT_FILE="/tmp/cogvision-performance-$(date +%Y%m%d).txt"
API_URL="https://api.cogvision.com"

echo "📊 CogVision 性能监控报告" > $REPORT_FILE
echo "生成时间: $(date)" >> $REPORT_FILE
echo "======================================" >> $REPORT_FILE

# 系统负载
echo "" >> $REPORT_FILE
echo "系统负载:" >> $REPORT_FILE
uptime >> $REPORT_FILE

# CPU使用率
echo "" >> $REPORT_FILE
echo "CPU使用率:" >> $REPORT_FILE
top -bn1 | grep "Cpu(s)" >> $REPORT_FILE

# 内存使用
echo "" >> $REPORT_FILE
echo "内存使用:" >> $REPORT_FILE
free -h >> $REPORT_FILE

# 磁盘IO
echo "" >> $REPORT_FILE
echo "磁盘IO:" >> $REPORT_FILE
iostat -x 1 1 >> $REPORT_FILE

# 网络连接
echo "" >> $REPORT_FILE
echo "网络连接统计:" >> $REPORT_FILE
netstat -s | grep -E "(connections|requests)" >> $REPORT_FILE

# API响应时间测试
echo "" >> $REPORT_FILE
echo "API响应时间测试:" >> $REPORT_FILE
for endpoint in "/health" "/api/dashboard/metrics" "/api/sessions/search"; do
    response_time=$(curl -o /dev/null -s -w "%{time_total}" "$API_URL$endpoint")
    echo "$endpoint: ${response_time}s" >> $REPORT_FILE
done

# 数据库性能
echo "" >> $REPORT_FILE
echo "数据库连接数:" >> $REPORT_FILE
psql -h localhost -U cogvision_user -d cogvision -c "SELECT count(*) as active_connections FROM pg_stat_activity;" >> $REPORT_FILE

echo "📊 性能监控完成，报告已保存到: $REPORT_FILE"
```

---

## 10. 故障排查

### 10.1 常见问题诊断

**前端无法访问:**
```bash
# 检查Nginx状态
sudo systemctl status nginx
sudo nginx -t

# 查看Nginx错误日志
sudo tail -f /var/log/nginx/error.log

# 检查端口占用
sudo netstat -tulpn | grep :80
sudo netstat -tulpn | grep :443

# 检查SSL证书
openssl x509 -in /etc/ssl/certs/cogvision.crt -text -noout
```

**后端API错误:**
```bash
# 查看应用日志
sudo journalctl -u cogvision-api -f

# 检查进程状态
ps aux | grep cogvision

# 检查端口监听
sudo netstat -tulpn | grep :8080

# 检查应用健康
curl -I http://localhost:8080/health
```

**数据库连接问题:**
```bash
# 检查PostgreSQL状态
sudo systemctl status postgresql
sudo -u postgres psql -c "SELECT version();"

# 查看连接数
sudo -u postgres psql -c "SELECT count(*) FROM pg_stat_activity;"

# 检查慢查询
sudo -u postgres psql -c "SELECT query, query_start, now() - query_start AS duration FROM pg_stat_activity WHERE now() - query_start > interval '30 seconds';"

# 查看数据库日志
sudo tail -f /var/log/postgresql/postgresql-*.log
```

### 10.2 故障恢复流程

**服务宕机恢复:**
```bash
#!/bin/bash
# 服务恢复脚本

echo "🚨 开始故障恢复流程..."

# 1. 停止所有服务
echo "停止服务..."
sudo systemctl stop nginx
sudo systemctl stop cogvision-api

# 2. 检查进程
echo "检查残留进程..."
pkill -f cogvision || true

# 3. 清理临时文件
echo "清理临时文件..."
sudo rm -rf /tmp/cogvision-*
sudo rm -rf /var/run/cogvision-*

# 4. 检查磁盘空间
echo "检查磁盘空间..."
df -h

# 5. 启动数据库服务
echo "启动数据库服务..."
sudo systemctl start postgresql
sudo systemctl start redis-server

# 等待数据库启动
sleep 10

# 6. 启动应用服务
echo "启动应用服务..."
sudo systemctl start cogvision-api
sleep 5
sudo systemctl start nginx

# 7. 验证服务状态
echo "验证服务状态..."
curl -f http://localhost:8080/health
curl -f http://localhost/

echo "✅ 故障恢复完成！"
```

**数据恢复流程:**
```bash
#!/bin/bash
# 数据恢复脚本

BACKUP_FILE="$1"
DB_NAME="cogvision"
DB_USER="cogvision_user"

if [ -z "$BACKUP_FILE" ]; then
    echo "用法: $0 <backup_file.sql.gz>"
    exit 1
fi

echo "🗄️ 开始数据恢复流程..."

# 1. 停止应用服务
echo "停止应用服务..."
sudo systemctl stop cogvision-api

# 2. 创建数据库备份
echo "创建当前数据库备份..."
pg_dump -h localhost -U $DB_USER -d $DB_NAME -f "/tmp/pre_restore_backup_$(date +%Y%m%d_%H%M%S).sql"

# 3. 删除现有数据库
echo "删除现有数据库..."
sudo -u postgres psql -c "DROP DATABASE IF EXISTS $DB_NAME;"

# 4. 创建新数据库
echo "创建新数据库..."
sudo -u postgres psql -c "CREATE DATABASE $DB_NAME OWNER $DB_USER;"

# 5. 恢复数据
echo "恢复数据..."
gunzip -c "$BACKUP_FILE" | psql -h localhost -U $DB_USER -d $DB_NAME

if [ $? -eq 0 ]; then
    echo "✅ 数据恢复成功"
else
    echo "❌ 数据恢复失败"
    exit 1
fi

# 6. 启动应用服务
echo "启动应用服务..."
sudo systemctl start cogvision-api

# 7. 验证恢复
echo "验证数据恢复..."
curl -f http://localhost:8080/health

echo "🎉 数据恢复完成！"
```

### 10.3 性能优化指南

**数据库性能优化:**
```sql
-- 分析慢查询
SELECT query, mean_time, calls, total_time
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 10;

-- 检查索引使用情况
SELECT schemaname, tablename, attname, n_distinct, correlation
FROM pg_stats
WHERE schemaname = 'public'
ORDER BY n_distinct DESC;

-- 分析表大小
SELECT schemaname, tablename, 
       pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
       pg_total_relation_size(schemaname||'.'||tablename) as size_bytes
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY size_bytes DESC;
```

**应用性能优化:**
```bash
# Node.js应用内存分析
node --inspect=0.0.0.0:9229 server.js

# 生成Heap Dump
kill -USR2 $(pgrep -f "node.*server.js")

# CPU性能分析
perf record -g node server.js
perf report
```

---

## 总结

本部署运维指南涵盖了CogVision系统的完整部署和运维流程，包括：

1. **环境准备** - 系统要求、依赖安装
2. **服务部署** - 前端、后端、数据库配置
3. **容器化** - Docker和Kubernetes部署
4. **CI/CD** - 自动化构建和部署
5. **监控告警** - Prometheus、Grafana配置
6. **日常运维** - 健康检查、备份、清理脚本
7. **故障排查** - 问题诊断和恢复流程

通过遵循本指南，可以确保CogVision系统的稳定运行和高可用性。

---

**文档版本:** v1.0  
**最后更新:** 2024-08-21  
**维护人员:** DevOps团队  
**联系方式:** ops@cogvision.com